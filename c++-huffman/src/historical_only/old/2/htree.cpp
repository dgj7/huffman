/******************************************************************************
	HUFFMAN CODING TREE - implementation file
	-------------------
	FILE: 		htree.cpp
	PURPOSE: 	huffman tree implementation

	PROGRAMMER: David Garcia Jr, dagarcia@umflint.edu
******************************************************************************/
#include <stddef.h>		// for NULL
#include <iostream>		// for debug functions only
#include <climits>		// INT_MAX
#include <vector>

#include "htree.h"

/******************************************************************************
	HUFFMAN COMPRESS
******************************************************************************/

HuffmanCompress::HuffmanCompress( stringtype input )
{
	// iterate through the string and store frequency data in a vector
	for( size_t n = 0; n < input.size(  ); n++ )
	{
		size_t loc = 0;
		if( p_find_char_in_frequency_vector( input[n], loc ) )
		{
			_freqdata[loc].second++;
		}
		else
		{
			std::pair<Data, ulint> temp;
			temp.first = input[n];
			temp.second = 1;
			_freqdata.push_back( temp );
		}
	}
	
	// create a list of trees from the vector of freq data.
	// this must be done in a seperate step because theres no way of knowing
	// if the tree is only a leaf, so the htree class cant have accessors
	// which would allow it to be used like the vector<pair<t1,t2>> can be
	// used above
	for( size_t s = 0; s < _freqdata.size(  ); s++ )
	{
		HTree temp( _freqdata[s].first, _freqdata[s].second );
		_htlist.push_back( temp );
	}
	
	_htlist.sort(  );
	
	// start building the final HTree
	_finalTree = NULL;
	
	while( _htlist.size(  ) > 1 )
	{
		std::list<HTree>::iterator firstIter = _htlist.begin(  );
		std::list<HTree>::iterator secondIter = _htlist.begin(  );
		secondIter++;
		HTree newtree( (*firstIter), (*secondIter) );
		_htlist.erase( firstIter );
		_htlist.erase( secondIter );
		_htlist.push_back( newtree );
		_htlist.sort(  );
		
		if( _htlist.size(  ) == 1 )
		{
			std::list< HTree>::iterator htiter = _htlist.begin(  );
			_finalTree = new HTree( *htiter );
		}
	}
	
	// put the freq data into _codes variable
	// then, clear the other variables (to save memory)
	bool path[65535];
	p_write_codes( _finalTree->_root, 0, path, 0 );
	_htlist.clear(  );
	_freqdata.clear(  );
	
	// print the codes, FOR DEBUG ONLY
	std::cout << "\n[hufftree c'tor] codes generated by the HuffmanTree class:\n";
	std::cout << "SYMBOL\t  FREQUENCY\tCODE\t\tCOST\t\tCOST ANALYSIS\n";
	std::cout << "-------------------------------------------------------------------------------\n";
	_finalTree->print_codes(  );
}

//=============================================================================
// the name of this function sucks; need something more descriptive & accurate
// this function iterates through the tree & saves all the codes(paths)/symbols
// in the HuffmanCompress::_codes data member, which is of type: 
// std::vector< std::pair< Data, std::vector< bool > > >
//=============================================================================
void HuffmanCompress::p_write_codes( HNode *node, bool preDirection, bool path[], ulint pathLen )
{
	if( node == NULL )
		return;
	
	if( node == _finalTree->_root )
	{
		// dont do anything; didnt come from left or right
	}
	else
	{
		// if it's from the left
		if( preDirection == 0 )
			path[pathLen] = 0;
		else
			path[pathLen] = 1;
		pathLen++;
	}
	
	// if this node is a leaf, do the required work to it
	if( node->_left == NULL && node->_right == NULL )
	{
		ulint f = node->_frequency;
		std::pair< Data, std::vector< bool > > temp;
		temp.first = node->_data;
		std::vector<bool> tempCode;
		
		for( ulint i = 0; i < pathLen; i++ )
		{
			tempCode.push_back( path[i] );
		}
		
		temp.second = tempCode;
		_codes.push_back( temp );
	}
	else
	{
		// LEFT = 0, RIGHT = 1
		p_write_codes( node->_left, 0, path, pathLen );
		p_write_codes( node->_right, 1, path, pathLen );
	}
}

//=============================================================================
// the _frequency vector stores the (current) frequency of each of the symbols
// in the set of symbols being compressed.  this function checks to see if
// a certain symbol (char) is currently being stored in the vector yet.
// this allows us to call this function, and if the symbol exists, increment
// the counter for that variable, or make it 1 if it didnt previously exist.
//=============================================================================
bool HuffmanCompress::p_find_char_in_frequency_vector( Data findMe, size_t &location )
{
	//std::pair< Data, ulint> currentData;
	location = 0;
	// using simple search for now. NEEDS IMPROVEMENT!!!
	for( size_t i = 0; i < _freqdata.size(  ); i++ )
	{
		//currentData = _freqdata[i];
		//if( currentData.first == findMe )
		if( _freqdata[i].first == findMe )
		{
			location = i;
			return true;
		}
	}
	
	return false;
}

//=============================================================================
// search for the code based on the symbol
// needs improvement -- what if theres no code for the symbol?
//=============================================================================
bool HuffmanCompress::get_code_for_symbol( Data findMe, std::vector < bool > &retval )
{
	for( size_t x = 0; x < _codes.size(  ); x++ )
	{
		if( _codes[x].first == findMe )
		{
			retval = _codes[x].second;
			return true;
		}
	}
}

/******************************************************************************
	HNODE
******************************************************************************/
HNode::HNode(  )
{
	_left = NULL;
	_right = NULL;
}

//=============================================================================
// this function copies a binary tree.  simply pass the root node to copy to
// and the root node to copy from.  the function automagically traverses both
// trees and makes them identical along the way.
//=============================================================================
void copy_tree( HNode *&copyTo, HNode *copyFrom )
{
	if( copyFrom == NULL )
	{
		copyTo = NULL;
	}
	else
	{
		copyTo = new HNode(  );
		copyTo->_frequency = copyFrom->_frequency;
		copyTo->_data = copyFrom->_data;
		copyTo->_nodetype = copyFrom->_nodetype;
		
		copy_tree( copyTo->_left, copyFrom->_left );
		copy_tree( copyTo->_right, copyFrom->_right );
	}
}

/******************************************************************************
	HTREE
******************************************************************************/
// for trees with just one leaf node
HTree::HTree( Data data, ulint frequency )
{
	//std::cout << "calling HTree( " << data << ", " << frequency << " )...";
	_root = new HNode(  );
	_root->_nodetype = leaf;
	_root->_data = data;
	_root->_frequency = frequency;
	_root->_left = NULL;
	_root->_right = NULL;
}

// for trees with multiple nodes, ie combining trees
HTree::HTree( HTree lefttree, HTree righttree )
{
	//std::cout << "calling HTree( HTree, HTree ) with HTree( "
	//	  << lefttree.get_frequency(  ) << ", "
	//	  << righttree.get_frequency(  ) << " )\n";

	_root = new HNode(  );
	
	_root->_frequency = lefttree.get_frequency(  ) + righttree.get_frequency(  );
	_root->_nodetype = internal;
	
	copy_tree( _root->_left, lefttree._root );
	copy_tree( _root->_right, righttree._root );
}

// unparameterized constructor to ensure compatibility with std::list
HTree::HTree(  )
{
	_root = NULL;
}

// copy constructor
HTree::HTree( const HTree &copyFrom )
{
	//std::cout << "calling copy contructor.\n";
	copy_tree( _root, copyFrom._root );
}

// assignment
HTree &HTree::operator=( const HTree &copyFrom )
{
	if( this != &copyFrom )
	{
		p_kill_tree( _root );
		copy_tree( _root, copyFrom._root );
	}
	return *this;
}

// destructor
HTree::~HTree(  )
{
	//std::cout << "killing tree.";
	p_kill_tree( _root );
	//std::cout << "done.\n";
}

void HTree::p_kill_tree( HNode *&node )
{
	// Recurse to the bottom-most nodes in the tree.
	if( node->_left != NULL )
		p_kill_tree( node->_left );
	if( node->_right != NULL )
		p_kill_tree( node->_right );
	
	// Now we're at the bottom-most nodes. Start destroying things.
	if( node->_left != NULL )
	{
		delete node->_left;
		node->_left = NULL;
	}
	if( node->_right != NULL )
	{
		delete node->_right;
		node->_right = NULL;
	}
}

// sorting by FREQUENCY first,
// then by data (char)
// question: is left less than right?
bool operator<( HTree left, HTree right )
{
	ulint l = left.get_frequency(  );
	ulint r = right.get_frequency(  );
	
	if( l < r )
	{
		return true;
	}
	// if the frequencies are equal
	else if( l == r )
	{
		// if both left and right are internals, leave them alone
		if( left._root->_nodetype != leaf && right._root->_nodetype != leaf )
		{
			return true;
			// effectively leave it alone if it's an internal and the frequencies are equal
		}
		// if only one of the two is a leaf, the leaf is less than the internal
		else if( left._root->_nodetype == leaf && right._root->_nodetype != leaf )
		{
			return true;
		}
		else if( right._root->_nodetype == leaf && left._root->_nodetype != leaf )
		{
			return false;
		}
		// if left and right are both leaves, compare the data
		else if( left._root->_data < right._root->_data )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	// frequencies arent less than or equal to... so greater than
	else
	{
		return false;
	}
}

ulint HTree::get_frequency(  ) const
{
	//std::cout << "calling get_frequency(  )\n";
	return _root->_frequency;
}

void HTree::print_contents_inorder(  ) const
{
	//std::cout << "\ncalling print_contents_inorder(  )";
	p_print_contents_inorder( _root );
}

void HTree::p_print_contents_inorder( HNode *pointer ) const
{
	//std::cout << "calling p_print_contents_inorder(  )";
	if( pointer != NULL )
	{
		p_print_contents_inorder( pointer->_left );
	
		if( pointer->_nodetype == internal )
		{
			std::cout << "\n\t[ internal ]\t---\t["
				  << pointer->_frequency << "]";
		}
		else
		{
			std::cout << "\n\t[   leaf   ]\t["
				  << pointer->_data << "]\t["
				  << pointer->_frequency << "]";
		}
		
		p_print_contents_inorder( pointer->_right );
	}
}

void HTree::print_codes(  )
{
	bool path[65535];		// max size of wide character
	
	p_print_codes( _root, 0, path, 0 );
}

void HTree::p_print_codes( HNode *node, bool preDirection, bool path[], ulint pathLen )
{
	if( node == NULL )
		return;
		
	//static ulint totalNormalBytes = 0;
	//static ulint totalCompressedBytes = 0;
		
	if( node == _root )
	{
		// do nothing, didnt come from left or right
	}
	else
	{
		// if came from left
		if( preDirection == 0 )
			path[pathLen] = 0;
		else
			path[pathLen] = 1;
		
		pathLen++;
	}
	
	if( node->_left == NULL && node->_right == NULL )
	{
		ulint f = node->_frequency;
		
		std::string symbol;
		if( node->_data == '\n' )
			symbol = "\\n";
		else if( node->_data == '\t' )
			symbol = "\\t";
		else if( node->_data == ' ' )
			symbol = "[space]";
		else
			symbol = node->_data;
		
		std::cout << symbol << "\t  " << f << "\t\t";
		for( int i = 0; i < pathLen; i++ )
		{
			std::cout << path[i];
			if( i == ( pathLen - 1 ) )
			{
				std::cout << "\t\t[" << i+1 << " bits]\t[" << (i+1) * f << " vs " << f * 8 << "]";
				//totalNormalBytes += f * 8;
				//totalCompressedBytes += (i+1)*f;
				//std::cout << "\t[" << totalCompressedBytes << " vs " << totalNormalBytes << "]"; //\t[" << totalCompressedBytes / totalNormalBytes << "]";
			}
		}
			
		std::cout << "\n";
	}
	else
	{
		// LEFT is 0, RIGHT is 1  (SECOND argument)
		p_print_codes( node->_left, 0, path, pathLen );
		p_print_codes( node->_right, 1, path, pathLen );
	}
}
	
	
	
	
	
	
	
	
	